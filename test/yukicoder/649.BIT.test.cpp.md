---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: src/DataStructure/BinaryIndexedTree.hpp
    title: Binary-Indexed-Tree
  - icon: ':question:'
    path: src/Misc/compress.hpp
    title: "\u5EA7\u6A19\u5727\u7E2E"
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://yukicoder.me/problems/no/649
    links:
    - https://yukicoder.me/problems/no/649
  bundledCode: "#line 1 \"test/yukicoder/649.BIT.test.cpp\"\n#define PROBLEM \"https://yukicoder.me/problems/no/649\"\
    \n#include <iostream>\n#include <vector>\n#line 3 \"src/Misc/compress.hpp\"\n\
    #include <algorithm>\ntemplate <class T> auto compress(std::vector<T> &v) {\n\
    \ return std::sort(v.begin(), v.end()), v.erase(std::unique(v.begin(), v.end()),\
    \ v.end()), [&v](T x) { return std::lower_bound(v.begin(), v.end(), x) - v.begin();\
    \ };\n}\n#line 4 \"src/DataStructure/BinaryIndexedTree.hpp\"\ntemplate <typename\
    \ T> class BinaryIndexedTree {\n std::vector<T> dat;\npublic:\n BinaryIndexedTree(int\
    \ n): dat(n + 1, T()) {}\n BinaryIndexedTree(int n, T a): BinaryIndexedTree(std::vector<T>(n,\
    \ a)) {}\n BinaryIndexedTree(const std::vector<T>& y): dat(y.size() + 1, 0) {\n\
    \  for (int i= y.size(); i--;) dat[i + 1]= y[i];\n  for (int i= 1, e= dat.size(),\
    \ j; i < e; ++i)\n   if ((j= i + (i & -i)) < e) dat[j]+= dat[i];\n }\n void add(int\
    \ i, T a= 1) {\n  for (++i; i < (int)dat.size(); i+= i & -i) dat[i]+= a;\n }\n\
    \ T sum(int i) const {  // sum [0,i)\n  T s= 0;\n  for (; i; i&= i - 1) s+= dat[i];\n\
    \  return s;\n }\n T sum(int l, int r) const { return sum(r) - sum(l); }  // sum\
    \ [l,r)\n T operator[](int k) const { return sum(k + 1) - sum(k); }\n int find(T\
    \ k) const {  // min { i : sum(i+1) > k } -> kth element(0-indexed)\n  int i=\
    \ 0;\n  for (int p= 1 << (std::__lg(dat.size() - 1) + 1), e= dat.size(); p; p>>=\
    \ 1)\n   if (i + p < e && dat[i + p] <= k) k-= dat[i+= p];\n  return i + 1 ==\
    \ (int)dat.size() ? -1 : i;  // -1 -> no solutions\n }\n};\n#line 6 \"test/yukicoder/649.BIT.test.cpp\"\
    \nusing namespace std;\nsigned main() {\n cin.tie(0);\n ios::sync_with_stdio(0);\n\
    \ int Q, K;\n cin >> Q >> K;\n K--;\n vector<long long> query, x;\n while (Q--)\
    \ {\n  long long v;\n  cin >> v;\n  if (v == 1) cin >> v, x.push_back(v);\n  else\
    \ v= -1;\n  query.push_back(v);\n }\n auto id= compress(x);\n BinaryIndexedTree<long\
    \ long> bit(x.size());\n for (auto q: query)\n  if (q < 0) {\n   if (int i= bit.find(K);\
    \ i >= 0) cout << x[i] << '\\n', bit.add(i, -1);\n   else cout << -1 << endl;\n\
    \  } else bit.add(id(q), 1);\n return 0;\n}\n"
  code: "#define PROBLEM \"https://yukicoder.me/problems/no/649\"\n#include <iostream>\n\
    #include <vector>\n#include \"src/Misc/compress.hpp\"\n#include \"src/DataStructure/BinaryIndexedTree.hpp\"\
    \nusing namespace std;\nsigned main() {\n cin.tie(0);\n ios::sync_with_stdio(0);\n\
    \ int Q, K;\n cin >> Q >> K;\n K--;\n vector<long long> query, x;\n while (Q--)\
    \ {\n  long long v;\n  cin >> v;\n  if (v == 1) cin >> v, x.push_back(v);\n  else\
    \ v= -1;\n  query.push_back(v);\n }\n auto id= compress(x);\n BinaryIndexedTree<long\
    \ long> bit(x.size());\n for (auto q: query)\n  if (q < 0) {\n   if (int i= bit.find(K);\
    \ i >= 0) cout << x[i] << '\\n', bit.add(i, -1);\n   else cout << -1 << endl;\n\
    \  } else bit.add(id(q), 1);\n return 0;\n}\n"
  dependsOn:
  - src/Misc/compress.hpp
  - src/DataStructure/BinaryIndexedTree.hpp
  isVerificationFile: true
  path: test/yukicoder/649.BIT.test.cpp
  requiredBy: []
  timestamp: '2023-01-21 16:53:05+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/yukicoder/649.BIT.test.cpp
layout: document
redirect_from:
- /verify/test/yukicoder/649.BIT.test.cpp
- /verify/test/yukicoder/649.BIT.test.cpp.html
title: test/yukicoder/649.BIT.test.cpp
---
