---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: src/Math/Rational.hpp
    title: "\u6709\u7406\u6570 $\\mathbb{Q}$"
  - icon: ':question:'
    path: src/Math/binary_gcd.hpp
    title: Binary GCD
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://onlinejudge.u-aizu.ac.jp/challenges/sources/PCK/Final/0350
    links:
    - https://onlinejudge.u-aizu.ac.jp/challenges/sources/PCK/Final/0350
  bundledCode: "#line 1 \"test/aoj/0350.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/challenges/sources/PCK/Final/0350\"\
    \n#include <iostream>\n#include <string>\n#line 3 \"src/Math/Rational.hpp\"\n\
    #include <limits>\n#include <sstream>\n#line 2 \"src/Math/binary_gcd.hpp\"\n#include\
    \ <type_traits>\n#include <algorithm>\ntemplate <class Int> constexpr int bsf(Int\
    \ a) {\n if constexpr (sizeof(Int) == 16) {\n  uint64_t lo= a & uint64_t(-1);\n\
    \  return lo ? __builtin_ctzll(lo) : 64 + __builtin_ctzll(a >> 64);\n } else if\
    \ constexpr (sizeof(Int) == 8) return __builtin_ctzll(a);\n else return __builtin_ctz(a);\n\
    }\ntemplate <class Int> constexpr Int binary_gcd(Int a, Int b) {\n if (a == 0\
    \ || b == 0) return a + b;\n int n= bsf(a), m= bsf(b), s= 0;\n for (a>>= n, b>>=\
    \ m; a != b;) {\n  Int d= a - b;\n  bool f= a > b;\n  s= bsf(d), b= f ? b : a,\
    \ a= (f ? d : -d) >> s;\n }\n return a << std::min(n, m);\n}\n#line 6 \"src/Math/Rational.hpp\"\
    \ntemplate <class Int, bool reduction= true> struct Rational {\n Int num, den;\n\
    \ constexpr Rational(Int num= 0, Int den= 1): num(num), den(den) {\n  if (den\
    \ < 0) num= -num, den= -den;\n  if constexpr (reduction) reduce();\n }\n constexpr\
    \ void reduce() {\n  const Int g= binary_gcd(num < 0 ? -num : num, den);\n  num/=\
    \ g, den/= g;\n }\n constexpr Rational operator-() const { return Rational(-num,\
    \ den); }\n constexpr Rational operator+(const Rational &r) const { return Rational(num\
    \ * r.den + den * r.num, den * r.den); }\n constexpr Rational operator-(const\
    \ Rational &r) const { return Rational(num * r.den - den * r.num, den * r.den);\
    \ }\n constexpr Rational operator*(const Rational &r) const { return Rational(num\
    \ * r.num, den * r.den); }\n constexpr Rational operator/(const Rational &r) const\
    \ { return Rational(num * r.den, den * r.num); }\n Rational &operator+=(const\
    \ Rational &r) { return *this= *this + r; }\n Rational &operator-=(const Rational\
    \ &r) { return *this= *this - r; }\n Rational &operator*=(const Rational &r) {\
    \ return *this= *this * r; }\n Rational &operator/=(const Rational &r) { return\
    \ *this= *this / r; }\n constexpr bool operator==(const Rational &r) const {\n\
    \  if constexpr (reduction) return num == r.num && den == r.den;\n  else return\
    \ den == 0 && r.den == 0 ? num * r.num > 0 : num * r.den == den * r.num;\n }\n\
    \ constexpr bool operator!=(const Rational &r) const { return !(*this == r); }\n\
    \ constexpr bool operator<(const Rational &r) const {\n  if (den == 0 && r.den\
    \ == 0) return num < r.num;\n  else if (den == 0) return num < 0;\n  else if (r.den\
    \ == 0) return r.num > 0;\n  else return num * r.den < den * r.num;\n }\n constexpr\
    \ bool operator>(const Rational &r) const { return r < *this; }\n constexpr bool\
    \ operator<=(const Rational &r) const { return !(r < *this); }\n constexpr bool\
    \ operator>=(const Rational &r) const { return !(*this < r); }\n constexpr explicit\
    \ operator bool() const { return num != 0; }\n constexpr long double to_fp() const\
    \ { return (long double)num / den; }\n constexpr Int floor() const {\n  if constexpr\
    \ (reduction) return num < 0 ? -((-num + den - 1) / den) : num / den;\n  else\
    \ {\n   const Int n= num < 0 ? -num : num, d= den < 0 ? -den : den;\n   return\
    \ num * den < 0 ? -((n + d - 1) / d) : n / d;\n  }\n }\n std::string to_string()\
    \ const {\n  if (!num) return \"0\";\n  std::stringstream ss;\n  return ss <<\
    \ num << \"/\" << den, ss.str();\n }\n friend std::ostream &operator<<(std::ostream\
    \ &os, const Rational &r) { return os << r.to_string(); }\n};\ntemplate <class\
    \ Int> struct std::numeric_limits<Rational<Int, false>> {\n static constexpr Rational<Int,\
    \ false> max() noexcept { return Rational<Int, false>(1, 0); }\n static constexpr\
    \ Rational<Int, false> min() noexcept { return Rational<Int, false>(1, std::numeric_limits<Int>::max());\
    \ }\n static constexpr Rational<Int, false> lowest() noexcept { return Rational<Int,\
    \ false>(-1, 0); }\n};\ntemplate <class Int> struct std::numeric_limits<Rational<Int,\
    \ true>> {\n static constexpr Rational<Int, true> max() noexcept { return Rational<Int,\
    \ true>(1, 0); }\n static constexpr Rational<Int, true> min() noexcept { return\
    \ Rational<Int, true>(1, std::numeric_limits<Int>::max()); }\n static constexpr\
    \ Rational<Int, true> lowest() noexcept { return Rational<Int, true>(-1, 0); }\n\
    };\n#line 5 \"test/aoj/0350.test.cpp\"\nusing namespace std;\nsigned main() {\n\
    \ cin.tie(0);\n ios::sync_with_stdio(false);\n using Q= Rational<long long>;\n\
    \ string str;\n cin >> str;\n if (str.back() != ')') str+= \"(0)\";\n int pw[12]=\
    \ {1};\n for (int i= 0; i < 11; ++i) pw[i + 1]= pw[i] * 10;\n int p= str.find('.'),\
    \ q= str.find('(');\n string a= str.substr(0, p);\n string b= str.substr(p + 1,\
    \ q - p - 1);\n string c= str.substr(q + 1, str.size() - q - 2);\n int n= b.length();\n\
    \ Q ans= stoi(a);\n if (n) ans+= Q(stoi(b), pw[n]);\n ans+= Q(stoi(c), pw[n] *\
    \ (pw[c.length()] - 1));\n cout << ans << '\\n';\n return 0;\n}\n"
  code: "#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/challenges/sources/PCK/Final/0350\"\
    \n#include <iostream>\n#include <string>\n#include \"src/Math/Rational.hpp\"\n\
    using namespace std;\nsigned main() {\n cin.tie(0);\n ios::sync_with_stdio(false);\n\
    \ using Q= Rational<long long>;\n string str;\n cin >> str;\n if (str.back() !=\
    \ ')') str+= \"(0)\";\n int pw[12]= {1};\n for (int i= 0; i < 11; ++i) pw[i +\
    \ 1]= pw[i] * 10;\n int p= str.find('.'), q= str.find('(');\n string a= str.substr(0,\
    \ p);\n string b= str.substr(p + 1, q - p - 1);\n string c= str.substr(q + 1,\
    \ str.size() - q - 2);\n int n= b.length();\n Q ans= stoi(a);\n if (n) ans+= Q(stoi(b),\
    \ pw[n]);\n ans+= Q(stoi(c), pw[n] * (pw[c.length()] - 1));\n cout << ans << '\\\
    n';\n return 0;\n}"
  dependsOn:
  - src/Math/Rational.hpp
  - src/Math/binary_gcd.hpp
  isVerificationFile: true
  path: test/aoj/0350.test.cpp
  requiredBy: []
  timestamp: '2023-08-06 20:57:49+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/aoj/0350.test.cpp
layout: document
redirect_from:
- /verify/test/aoj/0350.test.cpp
- /verify/test/aoj/0350.test.cpp.html
title: test/aoj/0350.test.cpp
---
