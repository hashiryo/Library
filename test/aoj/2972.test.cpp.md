---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: src/Geometry/Point.hpp
    title: src/Geometry/Point.hpp
  - icon: ':heavy_check_mark:'
    path: src/Internal/function_type.hpp
    title: "\u95A2\u6570\u578B\u3084\u95A2\u6570\u30AA\u30D6\u30B8\u30A7\u30AF\u30C8\
      \u3092\u6271\u3046\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8"
  - icon: ':heavy_check_mark:'
    path: src/Optimization/MinMaxEnum.hpp
    title: "\u6700\u5927\u6700\u5C0F\u3092\u6307\u5B9A\u3059\u308B\u305F\u3081\u306E\
      \u5217\u6319\u578B"
  - icon: ':heavy_check_mark:'
    path: src/Optimization/golden_search.hpp
    title: "\u9EC4\u91D1\u5206\u5272\u63A2\u7D22"
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    ERROR: '0.0001'
    PROBLEM: https://onlinejudge.u-aizu.ac.jp/problems/2972
    links:
    - https://onlinejudge.u-aizu.ac.jp/problems/2972
  bundledCode: "#line 1 \"test/aoj/2972.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/problems/2972\"\
    \n#define ERROR \"0.0001\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\
    #include <iomanip>\n#line 2 \"src/Optimization/golden_search.hpp\"\n#include <cmath>\n\
    #include <cassert>\n#line 2 \"src/Internal/function_type.hpp\"\n#include <type_traits>\n\
    template <class C> struct is_function_object {\n template <class U, int dummy=\
    \ (&U::operator(), 0)> static std::true_type check(U *);\n static std::false_type\
    \ check(...);\n static C *m;\n static constexpr bool value= decltype(check(m))::value;\n\
    };\ntemplate <class F, bool, bool> struct function_type_impl {\n using type= void;\n\
    };\ntemplate <class F> struct function_type_impl<F, true, false> {\n using type=\
    \ F *;\n};\ntemplate <class F> struct function_type_impl<F, false, true> {\n using\
    \ type= decltype(&F::operator());\n};\ntemplate <class F> using function_type_t=\
    \ typename function_type_impl<F, std::is_function_v<F>, is_function_object<F>::value>::type;\n\
    template <class... Args> struct result_type_impl {\n using type= void;\n};\ntemplate\
    \ <class R, class... Args> struct result_type_impl<R (*)(Args...)> {\n using type=\
    \ R;\n};\ntemplate <class C, class R, class... Args> struct result_type_impl<R\
    \ (C::*)(Args...)> {\n using type= R;\n};\ntemplate <class C, class R, class...\
    \ Args> struct result_type_impl<R (C::*)(Args...) const> {\n using type= R;\n\
    };\ntemplate <class F> using result_type_t= typename result_type_impl<function_type_t<F>>::type;\n\
    #line 2 \"src/Optimization/MinMaxEnum.hpp\"\nenum MinMaxEnum { MAXIMIZE= -1, MINIMIZE=\
    \ 1 };\n#line 6 \"src/Optimization/golden_search.hpp\"\n// [l,r]\ntemplate <MinMaxEnum\
    \ obj, class F> std::pair<long double, result_type_t<F>> golden_search(const F\
    \ &f, long double l, long double r, int iter= 100) {\n static constexpr long double\
    \ c= 0.38196601125;\n assert(l <= r);\n long double x= l + (r - l) * c, y= r -\
    \ (r - l) * c;\n result_type_t<F> fx= f(x), fy= f(y);\n for (bool g; iter--;)\
    \ {\n  if constexpr (obj == MINIMIZE) g= fx < fy;\n  else g= fx > fy;\n  if (g)\
    \ r= y, y= x, fy= fx, fx= f(x= l + (r - l) * c);\n  else l= x, x= y, fx= fy, fy=\
    \ f(y= r - (r - l) * c);\n }\n return {x, fx};\n}\n#line 3 \"src/Geometry/Point.hpp\"\
    \n#include <fstream>\n#line 7 \"src/Geometry/Point.hpp\"\nnamespace geo {\nusing\
    \ namespace std;\nstruct Visualizer {\n ofstream ofs;\n Visualizer(string s= \"\
    visualize.txt\"): ofs(s) { ofs << fixed << setprecision(10); }\n};\ntemplate <class\
    \ K> int sgn(K x) {\n if constexpr (is_floating_point_v<K>) {\n  static constexpr\
    \ K EPS= 1e-9;\n  return x < -EPS ? -1 : x > EPS;\n } else return x < 0 ? -1 :\
    \ x > 0;\n}\ntemplate <class K> K err_floor(const K &x) {\n K y= floor(x);\n if\
    \ constexpr (is_floating_point_v<K>)\n  if (K z= y + 1, w= x - z; 0 <= sgn(w)\
    \ && sgn(w - 1) < 0) return z;\n return y;\n}\ntemplate <class K> K err_ceil(const\
    \ K &x) {\n K y= ceil(x);\n if constexpr (is_floating_point_v<K>)\n  if (K z=\
    \ y - 1, w= x - z; 0 < sgn(w + 1) && sgn(w) <= 0) return z;\n return y;\n}\nlong\
    \ double radian_to_degree(long double r) { return r * 180.0 / M_PI; }\nlong double\
    \ degree_to_radian(long double d) { return d * M_PI / 180.0; }\ntemplate <class\
    \ K> struct Point {\n K x, y;\n Point(K x= K(), K y= K()): x(x), y(y) {}\n Point\
    \ &operator+=(const Point &p) { return x+= p.x, y+= p.y, *this; }\n Point &operator-=(const\
    \ Point &p) { return x-= p.x, y-= p.y, *this; }\n Point &operator*=(K a) { return\
    \ x*= a, y*= a, *this; }\n Point &operator/=(K a) { return x/= a, y/= a, *this;\
    \ }\n Point operator+(const Point &p) const { return {x + p.x, y + p.y}; }\n Point\
    \ operator-(const Point &p) const { return {x - p.x, y - p.y}; }\n Point operator*(K\
    \ a) const { return {x * a, y * a}; }\n Point operator/(K a) const { return {x\
    \ / a, y / a}; }\n friend Point operator*(K a, const Point &p) { return {a * p.x,\
    \ a * p.y}; }\n Point operator-() const { return {-x, -y}; }\n bool operator<(const\
    \ Point &p) const {\n  int s= sgn(x - p.x);\n  return s ? s < 0 : sgn(y - p.y)\
    \ < 0;\n }\n bool operator>(const Point &p) const { return p < *this; }\n bool\
    \ operator<=(const Point &p) const { return !(p < *this); }\n bool operator>=(const\
    \ Point &p) const { return !(*this < p); }\n bool operator==(const Point &p) const\
    \ { return !sgn(x - p.x) && !sgn(y - p.y); }\n bool operator!=(const Point &p)\
    \ const { return sgn(x - p.x) || sgn(y - p.y); }\n Point operator!() const { return\
    \ {-y, x}; }  // rotate 90 degree\n friend istream &operator>>(istream &is, Point\
    \ &p) { return is >> p.x >> p.y; }\n friend ostream &operator<<(ostream &os, const\
    \ Point &p) { return os << \"(\" << p.x << \", \" << p.y << \")\"; }\n friend\
    \ Visualizer &operator<<(Visualizer &vis, const Point &p) { return vis.ofs <<\
    \ p.x << \" \" << p.y << \"\\n\", vis; }\n};\ntemplate <class K> K dot(const Point<K>\
    \ &p, const Point<K> &q) { return p.x * q.x + p.y * q.y; }\n// left turn: > 0,\
    \ right turn: < 0\ntemplate <class K> K cross(const Point<K> &p, const Point<K>\
    \ &q) { return p.x * q.y - p.y * q.x; }\ntemplate <class K> K norm(const Point<K>\
    \ &p) { return dot(p, p); }\ntemplate <class K> long double abs(const Point<K>\
    \ &p) { return sqrt(norm(p)); }\ntemplate <class K> K dist2(const Point<K> &p,\
    \ const Point<K> &q) { return norm(p - q); }\ntemplate <class T, class U> long\
    \ double dist(const T &a, const U &b) { return sqrt(dist2(a, b)); }\ntemplate\
    \ <class K> long double angle(const Point<K> &p) { return atan2(p.y, p.x); }\n\
    template <class K> long double angle(const Point<K> &p, const Point<K> &q) { return\
    \ atan2(cross(p, q), dot(p, q)); }\nenum CCW { COUNTER_CLOCKWISE, CLOCKWISE, ONLINE_BACK,\
    \ ONLINE_FRONT, ON_SEGMENT };\nostream &operator<<(ostream &os, CCW c) { return\
    \ os << (c == COUNTER_CLOCKWISE ? \"COUNTER_CLOCKWISE\" : c == CLOCKWISE ? \"\
    CLOCKWISE\" : c == ONLINE_BACK ? \"ONLINE_BACK\" : c == ONLINE_FRONT ? \"ONLINE_FRONT\"\
    \ : \"ON_SEGMENT\"); }\ntemplate <class K> CCW ccw(const Point<K> &p0, const Point<K>\
    \ &p1, const Point<K> &p2) {\n Point a= p1 - p0, b= p2 - p0;\n if (int s= sgn(cross(a,\
    \ b)); s) return s > 0 ? COUNTER_CLOCKWISE : CLOCKWISE;\n if (K d= dot(a, b);\
    \ sgn(d) < 0) return ONLINE_BACK;\n else return sgn(d - norm(a)) > 0 ? ONLINE_FRONT\
    \ : ON_SEGMENT;\n}\ntemplate <class K> struct Line;\ntemplate <class K> struct\
    \ Segment;\ntemplate <class K> struct Circle;\ntemplate <class K> struct Polygon;\n\
    template <class K> struct Convex;\ntemplate <class K> struct Affine {\n K a00=\
    \ 1, a01= 0, a10= 0, a11= 1;\n Point<K> b;\n Point<K> operator()(const Point<K>\
    \ &p) const { return {a00 * p.x + a01 * p.y + b.x, a10 * p.x + a11 * p.y + b.y};\
    \ }\n Line<K> operator()(const Line<K> &l);\n Segment<K> operator()(const Segment<K>\
    \ &s);\n Circle<K> operator()(const Circle<K> &c);\n Polygon<K> operator()(const\
    \ Polygon<K> &p);\n Convex<K> operator()(const Convex<K> &c);\n Affine operator*(const\
    \ Affine &r) const { return {a00 * r.a00 + a01 * r.a10, a00 * r.a01 + a01 * r.a11,\
    \ a10 * r.a00 + a11 * r.a10, a10 * r.a01 + a11 * r.a11, (*this)(r)}; }\n Affine\
    \ &operator*=(const Affine &r) { return *this= *this * r; }\n};\ntemplate <class\
    \ K> Affine<K> translate(const Point<K> &p) { return {1, 0, 0, 1, p}; }\ntemplate\
    \ <class K> Affine<K> rotate(long double theta) {\n K c= cos(theta), s= sin(theta);\n\
    \ return {c, -s, s, c, Point<K>{0, 0}};\n}\ntemplate <class K> Affine<K> rotate(const\
    \ Point<K> &p, long double theta) {\n K c= cos(theta), s= sin(theta);\n return\
    \ {c, -s, s, c, Point<K>{p.x - c * p.x + s * p.y, p.y - s * p.x - c * p.y}};\n\
    }\ntemplate <class K> Affine<K> rotate90(const Point<K> &p) { return {0, -1, 1,\
    \ 0, p - !p}; }\n}\n#line 9 \"test/aoj/2972.test.cpp\"\nusing namespace std;\n\
    signed main() {\n cin.tie(0);\n ios::sync_with_stdio(false);\n using namespace\
    \ geo;\n using R= long double;\n int N, K;\n cin >> N >> K;\n vector<Point<R>>\
    \ ps(N);\n for (int i= 0; i < N; ++i) cin >> ps[i];\n auto score= [&](const Point<R>\
    \ &p) {\n  vector<R> dis(N);\n  for (int i= 0; i < N; ++i) dis[i]= dist(ps[i],\
    \ p);\n  sort(dis.rbegin(), dis.rend());\n  R ret= 0;\n  for (int i= 0; i < K;\
    \ ++i) ret+= dis[i];\n  return ret;\n };\n auto f= [&](R x) {\n  auto g= [&](R\
    \ y) { return score({x, y}); };\n  return golden_search<MINIMIZE>(g, -1000.0,\
    \ 1000.0).second;\n };\n cout << fixed << setprecision(10) << golden_search<MINIMIZE>(f,\
    \ -1000.0, 1000.0).second << '\\n';\n return 0;\n}\n"
  code: "#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/problems/2972\"\n#define\
    \ ERROR \"0.0001\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\
    #include <iomanip>\n#include \"src/Optimization/golden_search.hpp\"\n#include\
    \ \"src/Geometry/Point.hpp\"\nusing namespace std;\nsigned main() {\n cin.tie(0);\n\
    \ ios::sync_with_stdio(false);\n using namespace geo;\n using R= long double;\n\
    \ int N, K;\n cin >> N >> K;\n vector<Point<R>> ps(N);\n for (int i= 0; i < N;\
    \ ++i) cin >> ps[i];\n auto score= [&](const Point<R> &p) {\n  vector<R> dis(N);\n\
    \  for (int i= 0; i < N; ++i) dis[i]= dist(ps[i], p);\n  sort(dis.rbegin(), dis.rend());\n\
    \  R ret= 0;\n  for (int i= 0; i < K; ++i) ret+= dis[i];\n  return ret;\n };\n\
    \ auto f= [&](R x) {\n  auto g= [&](R y) { return score({x, y}); };\n  return\
    \ golden_search<MINIMIZE>(g, -1000.0, 1000.0).second;\n };\n cout << fixed <<\
    \ setprecision(10) << golden_search<MINIMIZE>(f, -1000.0, 1000.0).second << '\\\
    n';\n return 0;\n}"
  dependsOn:
  - src/Optimization/golden_search.hpp
  - src/Internal/function_type.hpp
  - src/Optimization/MinMaxEnum.hpp
  - src/Geometry/Point.hpp
  isVerificationFile: true
  path: test/aoj/2972.test.cpp
  requiredBy: []
  timestamp: '2023-09-20 18:34:32+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/aoj/2972.test.cpp
layout: document
redirect_from:
- /verify/test/aoj/2972.test.cpp
- /verify/test/aoj/2972.test.cpp.html
title: test/aoj/2972.test.cpp
---
