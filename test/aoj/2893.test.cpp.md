---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: src/Graph/Graph.hpp
    title: "\u30B0\u30E9\u30D5"
  - icon: ':question:'
    path: src/Graph/IncrementalBridgeConnectivity.hpp
    title: "Incremental-Bridge-Connectivity (\u4E8C\u8FBA\u9023\u7D50\u6210\u5206)"
  - icon: ':question:'
    path: src/Internal/ListRange.hpp
    title: "CSR \u8868\u73FE\u3092\u7528\u3044\u305F\u4E8C\u6B21\u5143\u914D\u5217\
      \ \u4ED6"
  - icon: ':question:'
    path: src/Misc/compress.hpp
    title: "\u5EA7\u6A19\u5727\u7E2E"
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://onlinejudge.u-aizu.ac.jp/problems/2893
    links:
    - https://onlinejudge.u-aizu.ac.jp/problems/2893
  bundledCode: "#line 1 \"test/aoj/2893.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/problems/2893\"\
    \n#include <iostream>\n#include <vector>\n#include <algorithm>\n#line 4 \"src/Internal/ListRange.hpp\"\
    \n#include <iterator>\n#include <type_traits>\n#define _LR(name, IT, CT) \\\n\
    \ template <class T> struct name { \\\n  using Iterator= typename std::vector<T>::IT;\
    \ \\\n  Iterator bg, ed; \\\n  Iterator begin() const { return bg; } \\\n  Iterator\
    \ end() const { return ed; } \\\n  size_t size() const { return std::distance(bg,\
    \ ed); } \\\n  CT &operator[](int i) const { return bg[i]; } \\\n }\n_LR(ListRange,\
    \ iterator, T);\n_LR(ConstListRange, const_iterator, const T);\n#undef _LR\ntemplate\
    \ <class T> struct CSRArray {\n std::vector<T> dat;\n std::vector<int> p;\n size_t\
    \ size() const { return p.size() - 1; }\n ListRange<T> operator[](int i) { return\
    \ {dat.begin() + p[i], dat.begin() + p[i + 1]}; }\n ConstListRange<T> operator[](int\
    \ i) const { return {dat.cbegin() + p[i], dat.cbegin() + p[i + 1]}; }\n};\ntemplate\
    \ <template <class> class F, class T> std::enable_if_t<std::disjunction_v<std::is_same<F<T>,\
    \ ListRange<T>>, std::is_same<F<T>, ConstListRange<T>>, std::is_same<F<T>, CSRArray<T>>>,\
    \ std::ostream &> operator<<(std::ostream &os, const F<T> &r) {\n os << '[';\n\
    \ for (int _= 0, __= r.size(); _ < __; ++_) os << (_ ? \", \" : \"\") << r[_];\n\
    \ return os << ']';\n}\n#line 3 \"src/Graph/Graph.hpp\"\nstruct Edge: std::pair<int,\
    \ int> {\n using std::pair<int, int>::pair;\n Edge &operator--() { return --first,\
    \ --second, *this; }\n int to(int v) const { return first ^ second ^ v; }\n friend\
    \ std::istream &operator>>(std::istream &is, Edge &e) { return is >> e.first >>\
    \ e.second, is; }\n};\nstruct Graph: std::vector<Edge> {\n size_t n;\n Graph(size_t\
    \ n= 0, size_t m= 0): vector(m), n(n) {}\n size_t vertex_size() const { return\
    \ n; }\n size_t edge_size() const { return size(); }\n size_t add_vertex() { return\
    \ n++; }\n size_t add_edge(int s, int d) { return emplace_back(s, d), size() -\
    \ 1; }\n size_t add_edge(Edge e) { return emplace_back(e), size() - 1; }\n#define\
    \ _ADJ_FOR(a, b) \\\n for (auto [u, v]: *this) a; \\\n for (size_t i= 0; i < n;\
    \ ++i) p[i + 1]+= p[i]; \\\n for (int i= size(); i--;) { \\\n  auto [u, v]= (*this)[i];\
    \ \\\n  b; \\\n }\n#define _ADJ(a, b) \\\n vector<int> p(n + 1), c(size() << !dir);\
    \ \\\n if (!dir) { \\\n  _ADJ_FOR((++p[u], ++p[v]), (c[--p[u]]= a, c[--p[v]]=\
    \ b)) \\\n } else if (dir > 0) { \\\n  _ADJ_FOR(++p[u], c[--p[u]]= a) \\\n } else\
    \ { \\\n  _ADJ_FOR(++p[v], c[--p[v]]= b) \\\n } \\\n return {c, p}\n CSRArray<int>\
    \ adjacency_vertex(int dir) const { _ADJ(v, u); }\n CSRArray<int> adjacency_edge(int\
    \ dir) const { _ADJ(i, i); }\n#undef _ADJ\n#undef _ADJ_FOR\n};\n#line 4 \"src/Misc/compress.hpp\"\
    \ntemplate <class T> auto compress(std::vector<T> &v) {\n return std::sort(v.begin(),\
    \ v.end()), v.erase(std::unique(v.begin(), v.end()), v.end()), [&v](T x) { return\
    \ std::lower_bound(v.begin(), v.end(), x) - v.begin(); };\n}\n#line 2 \"src/Graph/IncrementalBridgeConnectivity.hpp\"\
    \n#include <utility>\n#line 4 \"src/Graph/IncrementalBridgeConnectivity.hpp\"\n\
    class IncrementalBridgeConnectivity {\n std::vector<int> cp, bp, bbf, z;\n int\
    \ t;\n inline int crt(int v) { return cp[v] < 0 ? v : cp[v]= crt(cp[v]); }\n inline\
    \ int par(int v) { return bbf[v] < 0 ? -1 : leader(bbf[v]); }\npublic:\n IncrementalBridgeConnectivity(int\
    \ n): cp(n, -1), bp(n, -1), bbf(n, -1), z(n), t(0) {}\n inline int leader(int\
    \ v) { return bp[v] < 0 ? v : bp[v]= leader(bp[v]); }\n int size(int v) { return\
    \ -bp[leader(v)]; }\n bool two_edge_connected(int u, int v) { return leader(u)\
    \ == leader(v); }\n bool connected(int u, int v) { return crt(u) == crt(v); }\n\
    \ void add_edge(int u, int v) {\n  int a= crt(u= leader(u)), b= crt(v= leader(v));\n\
    \  if (a == b)\n   for (++t, a= u, b= v;;) {\n    if (z[a] == t) {\n     for (int\
    \ w: {u, v})\n      for (int p; w= leader(w), w != a; bp[a]+= bp[w], bp[w]= a,\
    \ w= p)\n       if (p= bbf[w], bbf[w]= bbf[a]; bp[a] > bp[w]) std::swap(w, a);\n\
    \     return;\n    }\n    if (z[a]= t, a= par(a); b != -1) std::swap(a, b);\n\
    \   }\n  if (cp[a] < cp[b]) std::swap(u, v), cp[a]+= cp[b], cp[b]= a;\n  else\
    \ cp[b]+= cp[a], cp[a]= b;\n  for (int p; u != -1; u= p) p= par(u), bbf[u]= v,\
    \ v= u;\n }\n};\n#line 8 \"test/aoj/2893.test.cpp\"\nusing namespace std;\nsigned\
    \ main() {\n cin.tie(0);\n ios::sync_with_stdio(0);\n int N, M;\n cin >> N >>\
    \ M;\n Graph g(N, M);\n vector<long long> w(M);\n for (int i= 0; i < M; ++i) cin\
    \ >> g[i] >> w[i], --g[i];\n IncrementalBridgeConnectivity ibc(N);\n for (auto\
    \ [u, v]: g) ibc.add_edge(u, v);\n\n vector<int> id(N);\n int n= 0;\n for (int\
    \ i= 0; i < N; ++i)\n  if (ibc.leader(i) == i) id[i]= n++;\n\n Graph g2(n);\n\
    \ vector<long long> s(n, 0), w2;\n for (int e= M; e--;) {\n  auto [u, v]= g[e];\n\
    \  u= id[ibc.leader(u)], v= id[ibc.leader(v)];\n  if (u == v) s[u]+= w[e];\n \
    \ else g2.add_edge(u, v), w2.push_back(w[e]);\n }\n\n auto adje= g2.adjacency_edge(0);\n\
    \n auto dfs= [&](auto &&dfs, int v, int p) -> void {\n  for (int e: adje[v])\n\
    \   if (int u= g2[e].to(v); u != p) {\n    dfs(dfs, u, v);\n    s[v]+= s[u] +\
    \ w2[e];\n   }\n };\n dfs(dfs, 0, -1);\n\n int ans_u= 0, ans_v= 0;\n long long\
    \ best= 1ll << 60;\n\n for (int e= 0; e < M; ++e) {\n  auto [u, v]= g[e];\n  int\
    \ u2= id[ibc.leader(u)], v2= id[ibc.leader(v)];\n  long long cost;\n  if (u2 ==\
    \ v2) cost= s[0] - w[e];\n  else {\n   if (s[u2] > s[v2]) swap(u2, v2);\n   long\
    \ long WA= s[u2], WB= s[0] - s[u2] - w[e];\n   cost= abs(WA - WB);\n  }\n  if\
    \ (best > cost) best= cost, ans_u= u, ans_v= v;\n  else if (best == cost) {\n\
    \   if (ans_u > u) ans_u= u, ans_v= v;\n   else if (ans_u == u && ans_v > v) ans_v=\
    \ v;\n  }\n }\n\n cout << ans_u + 1 << \" \" << ans_v + 1 << '\\n';\n return 0;\n\
    }\n"
  code: "#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/problems/2893\"\n#include\
    \ <iostream>\n#include <vector>\n#include <algorithm>\n#include \"src/Graph/Graph.hpp\"\
    \n#include \"src/Misc/compress.hpp\"\n#include \"src/Graph/IncrementalBridgeConnectivity.hpp\"\
    \nusing namespace std;\nsigned main() {\n cin.tie(0);\n ios::sync_with_stdio(0);\n\
    \ int N, M;\n cin >> N >> M;\n Graph g(N, M);\n vector<long long> w(M);\n for\
    \ (int i= 0; i < M; ++i) cin >> g[i] >> w[i], --g[i];\n IncrementalBridgeConnectivity\
    \ ibc(N);\n for (auto [u, v]: g) ibc.add_edge(u, v);\n\n vector<int> id(N);\n\
    \ int n= 0;\n for (int i= 0; i < N; ++i)\n  if (ibc.leader(i) == i) id[i]= n++;\n\
    \n Graph g2(n);\n vector<long long> s(n, 0), w2;\n for (int e= M; e--;) {\n  auto\
    \ [u, v]= g[e];\n  u= id[ibc.leader(u)], v= id[ibc.leader(v)];\n  if (u == v)\
    \ s[u]+= w[e];\n  else g2.add_edge(u, v), w2.push_back(w[e]);\n }\n\n auto adje=\
    \ g2.adjacency_edge(0);\n\n auto dfs= [&](auto &&dfs, int v, int p) -> void {\n\
    \  for (int e: adje[v])\n   if (int u= g2[e].to(v); u != p) {\n    dfs(dfs, u,\
    \ v);\n    s[v]+= s[u] + w2[e];\n   }\n };\n dfs(dfs, 0, -1);\n\n int ans_u= 0,\
    \ ans_v= 0;\n long long best= 1ll << 60;\n\n for (int e= 0; e < M; ++e) {\n  auto\
    \ [u, v]= g[e];\n  int u2= id[ibc.leader(u)], v2= id[ibc.leader(v)];\n  long long\
    \ cost;\n  if (u2 == v2) cost= s[0] - w[e];\n  else {\n   if (s[u2] > s[v2]) swap(u2,\
    \ v2);\n   long long WA= s[u2], WB= s[0] - s[u2] - w[e];\n   cost= abs(WA - WB);\n\
    \  }\n  if (best > cost) best= cost, ans_u= u, ans_v= v;\n  else if (best == cost)\
    \ {\n   if (ans_u > u) ans_u= u, ans_v= v;\n   else if (ans_u == u && ans_v >\
    \ v) ans_v= v;\n  }\n }\n\n cout << ans_u + 1 << \" \" << ans_v + 1 << '\\n';\n\
    \ return 0;\n}"
  dependsOn:
  - src/Graph/Graph.hpp
  - src/Internal/ListRange.hpp
  - src/Misc/compress.hpp
  - src/Graph/IncrementalBridgeConnectivity.hpp
  isVerificationFile: true
  path: test/aoj/2893.test.cpp
  requiredBy: []
  timestamp: '2024-02-20 18:08:31+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/aoj/2893.test.cpp
layout: document
redirect_from:
- /verify/test/aoj/2893.test.cpp
- /verify/test/aoj/2893.test.cpp.html
title: test/aoj/2893.test.cpp
---
