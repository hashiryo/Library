---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: src/DataStructure/UnionFind.hpp
    title: Union-Find
  - icon: ':question:'
    path: src/Graph/Graph.hpp
    title: "\u30B0\u30E9\u30D5"
  - icon: ':question:'
    path: src/Graph/RangeToRangeGraph.hpp
    title: "\u533A\u9593\u306B\u8FBA\u3092\u5F35\u308B\u30C6\u30AF"
  - icon: ':question:'
    path: src/Internal/ListRange.hpp
    title: "CSR \u8868\u73FE\u3092\u7528\u3044\u305F\u4E8C\u6B21\u5143\u914D\u5217\
      \ \u4ED6"
  - icon: ':question:'
    path: src/Misc/compress.hpp
    title: "\u5EA7\u6A19\u5727\u7E2E"
  _extendedRequiredBy: []
  _extendedVerifiedWith: []
  _isVerificationFailed: false
  _pathExtension: cpp
  _verificationStatusIcon: ':heavy_check_mark:'
  attributes:
    '*NOT_SPECIAL_COMMENTS*': ''
    PROBLEM: https://onlinejudge.u-aizu.ac.jp/challenges/sources/UOA/UAPC/3506
    links:
    - https://onlinejudge.u-aizu.ac.jp/challenges/sources/UOA/UAPC/3506
  bundledCode: "#line 1 \"test/aoj/3506.test.cpp\"\n#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/challenges/sources/UOA/UAPC/3506\"\
    \n#include <iostream>\n#include <deque>\n#include <vector>\n#include <algorithm>\n\
    #line 4 \"src/Misc/compress.hpp\"\ntemplate <class T> auto compress(std::vector<T>\
    \ &v) {\n return std::sort(v.begin(), v.end()), v.erase(std::unique(v.begin(),\
    \ v.end()), v.end()), [&v](T x) { return std::lower_bound(v.begin(), v.end(),\
    \ x) - v.begin(); };\n}\n#line 4 \"src/DataStructure/UnionFind.hpp\"\n#include\
    \ <cassert>\ntemplate <bool undoable= false> class UnionFind {\n std::vector<int>\
    \ par;\n std::vector<std::pair<int, int>> his;\npublic:\n UnionFind(int n): par(n,\
    \ -1) {}\n bool unite(int u, int v) {\n  if ((u= root(u)) == (v= root(v))) return\
    \ false;\n  if (par[u] > par[v]) std::swap(u, v);\n  if constexpr (undoable) his.emplace_back(v,\
    \ par[v]);\n  return par[u]+= par[v], par[v]= u, true;\n }\n bool same(int u,\
    \ int v) { return root(u) == root(v); }\n int root(int u) {\n  if constexpr (undoable)\
    \ return par[u] < 0 ? u : root(par[u]);\n  else return par[u] < 0 ? u : par[u]=\
    \ root(par[u]);\n }\n int size(int u) { return -par[root(u)]; }\n int time() const\
    \ {\n  static_assert(undoable, \"\\'time\\' is not enabled\");\n  return his.size();\n\
    \ }\n void undo() {\n  static_assert(undoable, \"\\'undo\\' is not enabled\");\n\
    \  auto [u, s]= his.back();\n  his.pop_back(), par[par[u]]-= s, par[u]= s;\n }\n\
    \ void rollback(size_t t) {\n  static_assert(undoable, \"\\'rollback\\' is not\
    \ enabled\");\n  assert(t <= his.size());\n  while (his.size() > t) undo();\n\
    \ }\n};\n#line 4 \"src/Internal/ListRange.hpp\"\n#include <iterator>\n#include\
    \ <type_traits>\n#define _LR(name, IT, CT) \\\n template <class T> struct name\
    \ { \\\n  using Iterator= typename std::vector<T>::IT; \\\n  Iterator bg, ed;\
    \ \\\n  Iterator begin() const { return bg; } \\\n  Iterator end() const { return\
    \ ed; } \\\n  size_t size() const { return std::distance(bg, ed); } \\\n  CT &operator[](int\
    \ i) const { return bg[i]; } \\\n }\n_LR(ListRange, iterator, T);\n_LR(ConstListRange,\
    \ const_iterator, const T);\n#undef _LR\ntemplate <class T> struct CSRArray {\n\
    \ std::vector<T> dat;\n std::vector<int> p;\n size_t size() const { return p.size()\
    \ - 1; }\n ListRange<T> operator[](int i) { return {dat.begin() + p[i], dat.begin()\
    \ + p[i + 1]}; }\n ConstListRange<T> operator[](int i) const { return {dat.cbegin()\
    \ + p[i], dat.cbegin() + p[i + 1]}; }\n};\ntemplate <template <class> class F,\
    \ class T> std::enable_if_t<std::disjunction_v<std::is_same<F<T>, ListRange<T>>,\
    \ std::is_same<F<T>, ConstListRange<T>>, std::is_same<F<T>, CSRArray<T>>>, std::ostream\
    \ &> operator<<(std::ostream &os, const F<T> &r) {\n os << '[';\n for (int _=\
    \ 0, __= r.size(); _ < __; ++_) os << (_ ? \", \" : \"\") << r[_];\n return os\
    \ << ']';\n}\n#line 3 \"src/Graph/Graph.hpp\"\nstruct Edge: std::pair<int, int>\
    \ {\n using std::pair<int, int>::pair;\n Edge &operator--() { return --first,\
    \ --second, *this; }\n int to(int v) const { return first ^ second ^ v; }\n friend\
    \ std::istream &operator>>(std::istream &is, Edge &e) { return is >> e.first >>\
    \ e.second, is; }\n};\nstruct Graph: std::vector<Edge> {\n size_t n;\n Graph(size_t\
    \ n= 0, size_t m= 0): vector(m), n(n) {}\n size_t vertex_size() const { return\
    \ n; }\n size_t edge_size() const { return size(); }\n size_t add_vertex() { return\
    \ n++; }\n size_t add_edge(int s, int d) { return emplace_back(s, d), size() -\
    \ 1; }\n size_t add_edge(Edge e) { return emplace_back(e), size() - 1; }\n#define\
    \ _ADJ_FOR(a, b) \\\n for (auto [u, v]: *this) a; \\\n for (size_t i= 0; i < n;\
    \ ++i) p[i + 1]+= p[i]; \\\n for (int i= size(); i--;) { \\\n  auto [u, v]= (*this)[i];\
    \ \\\n  b; \\\n }\n#define _ADJ(a, b) \\\n vector<int> p(n + 1), c(size() << !dir);\
    \ \\\n if (!dir) { \\\n  _ADJ_FOR((++p[u], ++p[v]), (c[--p[u]]= a, c[--p[v]]=\
    \ b)) \\\n } else if (dir > 0) { \\\n  _ADJ_FOR(++p[u], c[--p[u]]= a) \\\n } else\
    \ { \\\n  _ADJ_FOR(++p[v], c[--p[v]]= b) \\\n } \\\n return {c, p}\n CSRArray<int>\
    \ adjacency_vertex(int dir) const { _ADJ(v, u); }\n CSRArray<int> adjacency_edge(int\
    \ dir) const { _ADJ(i, i); }\n#undef _ADJ\n#undef _ADJ_FOR\n};\n#line 3 \"src/Graph/RangeToRangeGraph.hpp\"\
    \ntemplate <typename cost_t= int> class RangeToRangeGraph {\n int n;\n inline\
    \ int to_upper_idx(int i) const { return i >= n ? i - n : n + i; }\n inline int\
    \ to_lower_idx(int i) const { return i >= n ? i - n : n + n + i; }\npublic:\n\
    \ Graph graph;\n std::vector<cost_t> weight;\n RangeToRangeGraph(int n): n(n),\
    \ graph(n * 3) {\n  for (int i= 2; i < n + n; ++i) add(to_upper_idx(i / 2), to_upper_idx(i));\n\
    \  for (int i= 2; i < n + n; ++i) add(to_lower_idx(i), to_lower_idx(i / 2));\n\
    \ }\n void add(int s, int t, cost_t w= 0) { graph.add_edge(s, t), weight.emplace_back(w);\
    \ }\n // [s_l, s_r) -> t\n void add_from_range(int s_l, int s_r, int t, cost_t\
    \ w= 0) {\n  for (int l= s_l + n, r= s_r + n; l < r; l>>= 1, r>>= 1) {\n   if\
    \ (l & 1) add(to_lower_idx(l++), t, w);\n   if (r & 1) add(to_lower_idx(--r),\
    \ t, w);\n  }\n }\n // s -> [t_l, t_r)\n void add_to_range(int s, int t_l, int\
    \ t_r, cost_t w= 0) {\n  for (int l= t_l + n, r= t_r + n; l < r; l>>= 1, r>>=\
    \ 1) {\n   if (l & 1) add(s, to_upper_idx(l++), w);\n   if (r & 1) add(s, to_upper_idx(--r),\
    \ w);\n  }\n }\n // [s_l, s_r) -> [t_l, t_r)\n void add_from_range_to_range(int\
    \ s_l, int s_r, int t_l, int t_r, cost_t w= 0) { add_from_range(s_l, s_r, graph.n,\
    \ w), add_to_range(graph.n, t_l, t_r, 0), ++graph.n; }\n};\n#line 9 \"test/aoj/3506.test.cpp\"\
    \nusing namespace std;\nsigned main() {\n cin.tie(0);\n ios::sync_with_stdio(0);\n\
    \ int N;\n cin >> N;\n int x[N], y[N];\n for (int i= 0; i < N; ++i) cin >> x[i]\
    \ >> y[i];\n vector vx(x, x + N), vy(y, y + N);\n auto idx= compress(vx);\n auto\
    \ idy= compress(vy);\n for (int i= 0; i < N; ++i) x[i]= idx(x[i]), y[i]= idy(y[i]);\n\
    \ int X= vx.size(), Y= vy.size();\n vector<int> x2i[X], y2i[Y];\n for (int i=\
    \ 0; i < N; ++i) x2i[x[i]].push_back(i), y2i[y[i]].push_back(i);\n UnionFind uf(N);\n\
    \ for (int z= X; z--;)\n  for (int i= x2i[z].size(); --i;) uf.unite(x2i[z][i],\
    \ x2i[z][i - 1]);\n for (int z= Y; z--;)\n  for (int i= y2i[z].size(); --i;) uf.unite(y2i[z][i],\
    \ y2i[z][i - 1]);\n int lx[N], rx[N], ly[N], ry[N];\n fill_n(lx, N, N + 1), fill_n(ly,\
    \ N, N + 1);\n fill_n(rx, N, -1), fill_n(ry, N, -1);\n for (int i= 0; i < N; ++i)\
    \ {\n  int r= uf.root(i);\n  lx[r]= min(lx[r], x[i]);\n  rx[r]= max(rx[r], x[i]);\n\
    \  ly[r]= min(ly[r], y[i]);\n  ry[r]= max(ry[r], y[i]);\n }\n RangeToRangeGraph<int>\
    \ r2r(N + X + Y);\n for (int i= 0; i < N; ++i) {\n  if (rx[i] == -1) continue;\n\
    \  r2r.add_from_range(N + lx[i], N + rx[i] + 1, i, 0);\n  r2r.add_to_range(i,\
    \ N + lx[i], N + rx[i] + 1, 1);\n  r2r.add_from_range(N + X + ly[i], N + X + ry[i]\
    \ + 1, i, 0);\n  r2r.add_to_range(i, N + X + ly[i], N + X + ry[i] + 1, 1);\n }\n\
    \ int n= r2r.graph.vertex_size();\n auto adj= r2r.graph.adjacency_edge(1);\n deque<int>\
    \ dq;\n int s= uf.root(0), g= uf.root(N - 1);\n int dist[n], used[n];\n static\
    \ constexpr int INF= 1 << 30;\n fill_n(dist, n, INF);\n fill_n(used, n, 0);\n\
    \ dist[s]= 0;\n dq.push_back(s);\n while (!dq.empty()) {\n  int v= dq.front();\n\
    \  dq.pop_front();\n  if (v == g) break;\n  if (used[v]) continue;\n  used[v]=\
    \ true;\n  for (int e: adj[v]) {\n   int u= r2r.graph[e].to(v);\n   int w= r2r.weight[e];\n\
    \   if (dist[u] > dist[v] + w) {\n    dist[u]= dist[v] + w;\n    if (w) dq.push_back(u);\n\
    \    else dq.push_front(u);\n   }\n  }\n }\n cout << (dist[g] == INF ? -1 : dist[g])\
    \ << '\\n';\n return 0;\n}\n"
  code: "#define PROBLEM \"https://onlinejudge.u-aizu.ac.jp/challenges/sources/UOA/UAPC/3506\"\
    \n#include <iostream>\n#include <deque>\n#include <vector>\n#include <algorithm>\n\
    #include \"src/Misc/compress.hpp\"\n#include \"src/DataStructure/UnionFind.hpp\"\
    \n#include \"src/Graph/RangeToRangeGraph.hpp\"\nusing namespace std;\nsigned main()\
    \ {\n cin.tie(0);\n ios::sync_with_stdio(0);\n int N;\n cin >> N;\n int x[N],\
    \ y[N];\n for (int i= 0; i < N; ++i) cin >> x[i] >> y[i];\n vector vx(x, x + N),\
    \ vy(y, y + N);\n auto idx= compress(vx);\n auto idy= compress(vy);\n for (int\
    \ i= 0; i < N; ++i) x[i]= idx(x[i]), y[i]= idy(y[i]);\n int X= vx.size(), Y= vy.size();\n\
    \ vector<int> x2i[X], y2i[Y];\n for (int i= 0; i < N; ++i) x2i[x[i]].push_back(i),\
    \ y2i[y[i]].push_back(i);\n UnionFind uf(N);\n for (int z= X; z--;)\n  for (int\
    \ i= x2i[z].size(); --i;) uf.unite(x2i[z][i], x2i[z][i - 1]);\n for (int z= Y;\
    \ z--;)\n  for (int i= y2i[z].size(); --i;) uf.unite(y2i[z][i], y2i[z][i - 1]);\n\
    \ int lx[N], rx[N], ly[N], ry[N];\n fill_n(lx, N, N + 1), fill_n(ly, N, N + 1);\n\
    \ fill_n(rx, N, -1), fill_n(ry, N, -1);\n for (int i= 0; i < N; ++i) {\n  int\
    \ r= uf.root(i);\n  lx[r]= min(lx[r], x[i]);\n  rx[r]= max(rx[r], x[i]);\n  ly[r]=\
    \ min(ly[r], y[i]);\n  ry[r]= max(ry[r], y[i]);\n }\n RangeToRangeGraph<int> r2r(N\
    \ + X + Y);\n for (int i= 0; i < N; ++i) {\n  if (rx[i] == -1) continue;\n  r2r.add_from_range(N\
    \ + lx[i], N + rx[i] + 1, i, 0);\n  r2r.add_to_range(i, N + lx[i], N + rx[i] +\
    \ 1, 1);\n  r2r.add_from_range(N + X + ly[i], N + X + ry[i] + 1, i, 0);\n  r2r.add_to_range(i,\
    \ N + X + ly[i], N + X + ry[i] + 1, 1);\n }\n int n= r2r.graph.vertex_size();\n\
    \ auto adj= r2r.graph.adjacency_edge(1);\n deque<int> dq;\n int s= uf.root(0),\
    \ g= uf.root(N - 1);\n int dist[n], used[n];\n static constexpr int INF= 1 <<\
    \ 30;\n fill_n(dist, n, INF);\n fill_n(used, n, 0);\n dist[s]= 0;\n dq.push_back(s);\n\
    \ while (!dq.empty()) {\n  int v= dq.front();\n  dq.pop_front();\n  if (v == g)\
    \ break;\n  if (used[v]) continue;\n  used[v]= true;\n  for (int e: adj[v]) {\n\
    \   int u= r2r.graph[e].to(v);\n   int w= r2r.weight[e];\n   if (dist[u] > dist[v]\
    \ + w) {\n    dist[u]= dist[v] + w;\n    if (w) dq.push_back(u);\n    else dq.push_front(u);\n\
    \   }\n  }\n }\n cout << (dist[g] == INF ? -1 : dist[g]) << '\\n';\n return 0;\n\
    }"
  dependsOn:
  - src/Misc/compress.hpp
  - src/DataStructure/UnionFind.hpp
  - src/Graph/RangeToRangeGraph.hpp
  - src/Graph/Graph.hpp
  - src/Internal/ListRange.hpp
  isVerificationFile: true
  path: test/aoj/3506.test.cpp
  requiredBy: []
  timestamp: '2024-02-19 15:31:52+09:00'
  verificationStatus: TEST_ACCEPTED
  verifiedWith: []
documentation_of: test/aoj/3506.test.cpp
layout: document
redirect_from:
- /verify/test/aoj/3506.test.cpp
- /verify/test/aoj/3506.test.cpp.html
title: test/aoj/3506.test.cpp
---
