---
data:
  _extendedDependsOn:
  - icon: ':question:'
    path: src/Geometry/Point.hpp
    title: "\u70B9"
  _extendedRequiredBy:
  - icon: ':question:'
    path: src/Geometry/Circle.hpp
    title: "\u5186"
  - icon: ':question:'
    path: src/Geometry/Convex.hpp
    title: "\u51F8\u591A\u89D2\u5F62"
  - icon: ':question:'
    path: src/Geometry/Polygon.hpp
    title: "\u591A\u89D2\u5F62"
  - icon: ':question:'
    path: src/Geometry/Segment.hpp
    title: "\u7DDA\u5206"
  - icon: ':question:'
    path: src/Geometry/SegmentArrangement.hpp
    title: "\u7DDA\u5206\u30A2\u30EC\u30F3\u30B8\u30E1\u30F3\u30C8"
  - icon: ':question:'
    path: src/Geometry/intersection_area.hpp
    title: "\u5186\u3068\u306E\u5171\u901A\u90E8\u5206\u306E\u9762\u7A4D"
  - icon: ':question:'
    path: src/Geometry/min_enclosing_circle.hpp
    title: "\u6700\u5C0F\u5305\u542B\u5186"
  _extendedVerifiedWith:
  - icon: ':heavy_check_mark:'
    path: test/aoj/0253.test.cpp
    title: test/aoj/0253.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/0265.test.cpp
    title: test/aoj/0265.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/0273.test.cpp
    title: test/aoj/0273.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/0342.test.cpp
    title: test/aoj/0342.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/0356.test.cpp
    title: test/aoj/0356.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/0375.test.cpp
    title: test/aoj/0375.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/0445.test.cpp
    title: test/aoj/0445.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1033.test.cpp
    title: test/aoj/1033.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1047.test.cpp
    title: test/aoj/1047.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1050.test.cpp
    title: test/aoj/1050.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1066.test.cpp
    title: test/aoj/1066.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1067.test.cpp
    title: test/aoj/1067.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1132.test.cpp
    title: test/aoj/1132.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1157.test.cpp
    title: test/aoj/1157.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1171.test.cpp
    title: test/aoj/1171.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1183.test.cpp
    title: test/aoj/1183.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1190.test.cpp
    title: test/aoj/1190.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1198.test.cpp
    title: test/aoj/1198.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1226.test.cpp
    title: test/aoj/1226.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1242.longdouble.test.cpp
    title: test/aoj/1242.longdouble.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1242.rational.test.cpp
    title: test/aoj/1242.rational.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1267.test.cpp
    title: test/aoj/1267.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/1342.test.cpp
    title: test/aoj/1342.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2003.longdouble.test.cpp
    title: test/aoj/2003.longdouble.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2003.rational.test.cpp
    title: test/aoj/2003.rational.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2009.longdouble.test.cpp
    title: test/aoj/2009.longdouble.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2009.rational.test.cpp
    title: test/aoj/2009.rational.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2159.longdouble.test.cpp
    title: test/aoj/2159.longdouble.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2159.rational.test.cpp
    title: test/aoj/2159.rational.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2201.test.cpp
    title: test/aoj/2201.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2256.test.cpp
    title: test/aoj/2256.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2402.test.cpp
    title: test/aoj/2402.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2423.test.cpp
    title: test/aoj/2423.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2448.test.cpp
    title: test/aoj/2448.test.cpp
  - icon: ':x:'
    path: test/aoj/2495.test.cpp
    title: test/aoj/2495.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2514.test.cpp
    title: test/aoj/2514.test.cpp
  - icon: ':heavy_check_mark:'
    path: test/aoj/2626.test.cpp
    title: test/aoj/2626.test.cpp
  - icon: ':x:'
    path: test/aoj/3034.test.cpp
    title: test/aoj/3034.test.cpp
  - icon: ':x:'
    path: test/aoj/3049.test.cpp
    title: test/aoj/3049.test.cpp
  - icon: ':x:'
    path: test/aoj/3176.test.cpp
    title: test/aoj/3176.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_1_A.test.cpp
    title: test/aoj/CGL_1_A.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_1_B.test.cpp
    title: test/aoj/CGL_1_B.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_2_A.test.cpp
    title: test/aoj/CGL_2_A.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_2_B.test.cpp
    title: test/aoj/CGL_2_B.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_2_C.test.cpp
    title: test/aoj/CGL_2_C.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_2_D.test.cpp
    title: test/aoj/CGL_2_D.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_3_A.test.cpp
    title: test/aoj/CGL_3_A.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_3_B.test.cpp
    title: test/aoj/CGL_3_B.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_3_C.test.cpp
    title: test/aoj/CGL_3_C.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_4_A.test.cpp
    title: test/aoj/CGL_4_A.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_4_B.test.cpp
    title: test/aoj/CGL_4_B.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_4_C.test.cpp
    title: test/aoj/CGL_4_C.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_7_A.test.cpp
    title: test/aoj/CGL_7_A.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_7_B.test.cpp
    title: test/aoj/CGL_7_B.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_7_C.test.cpp
    title: test/aoj/CGL_7_C.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_7_D.test.cpp
    title: test/aoj/CGL_7_D.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_7_E.test.cpp
    title: test/aoj/CGL_7_E.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_7_F.test.cpp
    title: test/aoj/CGL_7_F.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_7_G.test.cpp
    title: test/aoj/CGL_7_G.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_7_H.test.cpp
    title: test/aoj/CGL_7_H.test.cpp
  - icon: ':x:'
    path: test/aoj/CGL_7_I.test.cpp
    title: test/aoj/CGL_7_I.test.cpp
  - icon: ':x:'
    path: test/atcoder/abc202_f.test.cpp
    title: test/atcoder/abc202_f.test.cpp
  _isVerificationFailed: true
  _pathExtension: hpp
  _verificationStatusIcon: ':question:'
  attributes:
    links: []
  bundledCode: "#line 2 \"src/Geometry/Line.hpp\"\n#include <vector>\n#line 2 \"src/Geometry/Point.hpp\"\
    \n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <cmath>\n\
    #include <cassert>\nnamespace geo {\nusing namespace std;\nstruct Visualizer {\n\
    \ ofstream ofs;\n Visualizer(string s= \"visualize.txt\"): ofs(s) { ofs << fixed\
    \ << setprecision(10); }\n friend Visualizer &operator<<(Visualizer &vis, const\
    \ string &s) { return vis.ofs << s, vis; }\n};\ntemplate <class K> int sgn(K x)\
    \ {\n if constexpr (is_floating_point_v<K>) {\n  static constexpr K EPS= 1e-9;\n\
    \  return x < -EPS ? -1 : x > EPS;\n } else return x < 0 ? -1 : x > 0;\n}\ntemplate\
    \ <class K> K err_floor(K x) {\n K y= floor(x);\n if constexpr (is_floating_point_v<K>)\n\
    \  if (K z= y + 1, w= x - z; 0 <= sgn(w) && sgn(w - 1) < 0) return z;\n return\
    \ y;\n}\ntemplate <class K> K err_ceil(K x) {\n K y= ceil(x);\n if constexpr (is_floating_point_v<K>)\n\
    \  if (K z= y - 1, w= x - z; 0 < sgn(w + 1) && sgn(w) <= 0) return z;\n return\
    \ y;\n}\ntemplate <class K> struct Point {\n K x, y;\n Point(K x= K(), K y= K()):\
    \ x(x), y(y) {}\n Point &operator+=(const Point &p) { return x+= p.x, y+= p.y,\
    \ *this; }\n Point &operator-=(const Point &p) { return x-= p.x, y-= p.y, *this;\
    \ }\n Point &operator*=(K a) { return x*= a, y*= a, *this; }\n Point &operator/=(K\
    \ a) { return x/= a, y/= a, *this; }\n Point operator+(const Point &p) const {\
    \ return {x + p.x, y + p.y}; }\n Point operator-(const Point &p) const { return\
    \ {x - p.x, y - p.y}; }\n Point operator*(K a) const { return {x * a, y * a};\
    \ }\n Point operator/(K a) const { return {x / a, y / a}; }\n friend Point operator*(K\
    \ a, const Point &p) { return {a * p.x, a * p.y}; }\n Point operator-() const\
    \ { return {-x, -y}; }\n bool operator<(const Point &p) const {\n  int s= sgn(x\
    \ - p.x);\n  return s ? s < 0 : sgn(y - p.y) < 0;\n }\n bool operator>(const Point\
    \ &p) const { return p < *this; }\n bool operator<=(const Point &p) const { return\
    \ !(p < *this); }\n bool operator>=(const Point &p) const { return !(*this < p);\
    \ }\n bool operator==(const Point &p) const { return !sgn(x - p.x) && !sgn(y -\
    \ p.y); }\n bool operator!=(const Point &p) const { return sgn(x - p.x) || sgn(y\
    \ - p.y); }\n Point operator!() const { return {-y, x}; }  // rotate 90 degree\n\
    \ friend istream &operator>>(istream &is, Point &p) { return is >> p.x >> p.y;\
    \ }\n friend ostream &operator<<(ostream &os, const Point &p) { return os << \"\
    (\" << p.x << \", \" << p.y << \")\"; }\n friend Visualizer &operator<<(Visualizer\
    \ &vis, const Point &p) { return vis.ofs << p.x << \" \" << p.y << \"\\n\", vis;\
    \ }\n};\ntemplate <class K> K dot(const Point<K> &p, const Point<K> &q) { return\
    \ p.x * q.x + p.y * q.y; }\n// left turn: > 0, right turn: < 0\ntemplate <class\
    \ K> K cross(const Point<K> &p, const Point<K> &q) { return p.x * q.y - p.y *\
    \ q.x; }\ntemplate <class K> K norm2(const Point<K> &p) { return dot(p, p); }\n\
    template <class K> long double norm(const Point<K> &p) { return sqrt(norm2(p));\
    \ }\ntemplate <class K> K dist2(const Point<K> &p, const Point<K> &q) { return\
    \ norm2(p - q); }\ntemplate <class T, class U> long double dist(const T &a, const\
    \ U &b) { return sqrt(dist2(a, b)); }\nenum CCW { COUNTER_CLOCKWISE, CLOCKWISE,\
    \ ONLINE_BACK, ONLINE_FRONT, ON_SEGMENT };\nostream &operator<<(ostream &os, CCW\
    \ c) { return os << (c == COUNTER_CLOCKWISE ? \"COUNTER_CLOCKWISE\" : c == CLOCKWISE\
    \ ? \"CLOCKWISE\" : c == ONLINE_BACK ? \"ONLINE_BACK\" : c == ONLINE_FRONT ? \"\
    ONLINE_FRONT\" : \"ON_SEGMENT\"); }\ntemplate <class K> CCW ccw(const Point<K>\
    \ &p0, const Point<K> &p1, const Point<K> &p2) {\n Point a= p1 - p0, b= p2 - p0;\n\
    \ int s;\n if constexpr (is_floating_point_v<K>) s= sgn(sgn(cross(a, b) / sqrt(norm2(a)\
    \ * norm2(b))));\n else s= sgn(cross(a, b));\n if (s) return s > 0 ? COUNTER_CLOCKWISE\
    \ : CLOCKWISE;\n if (K d= dot(a, b); sgn(d) < 0) return ONLINE_BACK;\n else return\
    \ sgn(d - norm2(a)) > 0 ? ONLINE_FRONT : ON_SEGMENT;\n}\ntemplate <class K> struct\
    \ Line;\ntemplate <class K> struct Segment;\ntemplate <class K> struct Polygon;\n\
    template <class K> struct Convex;\ntemplate <class K> struct Affine {\n K a00=\
    \ 1, a01= 0, a10= 0, a11= 1;\n Point<K> b;\n Point<K> operator()(const Point<K>\
    \ &p) const { return {a00 * p.x + a01 * p.y + b.x, a10 * p.x + a11 * p.y + b.y};\
    \ }\n Line<K> operator()(const Line<K> &l);\n Segment<K> operator()(const Segment<K>\
    \ &s);\n Polygon<K> operator()(const Polygon<K> &p);\n Convex<K> operator()(const\
    \ Convex<K> &c);\n Affine operator*(const Affine &r) const { return {a00 * r.a00\
    \ + a01 * r.a10, a00 * r.a01 + a01 * r.a11, a10 * r.a00 + a11 * r.a10, a10 * r.a01\
    \ + a11 * r.a11, (*this)(r)}; }\n Affine &operator*=(const Affine &r) { return\
    \ *this= *this * r; }\n};\ntemplate <class K> Affine<K> translate(const Point<K>\
    \ &p) { return {1, 0, 0, 1, p}; }\n}\n#line 4 \"src/Geometry/Line.hpp\"\nnamespace\
    \ geo {\ntemplate <class K> struct Line {\n using P= Point<K>;\n P p, d;  // p+td\n\
    \ Line() {}\n // p + td\n Line(const P &p, const P &d): p(p), d(d) { assert(sgn(norm2(d)));\
    \ }\n // ax+by+c=0 ................. ax+by+c>0: left, ax+by+c=0: on, ax+by+c<0:\
    \ right\n Line(K a, K b, K c) {\n  int sa= sgn(a), sb= sgn(b);\n  assert(sa ||\
    \ sb);\n  d= P{b, -a}, p= sb ? P{0, -c / b} : P{-c / a, 0};\n }\n bool operator==(const\
    \ Line &l) const { return !sgn(cross(d, l.d)) && !where(l.p); }\n bool operator!=(const\
    \ Line &l) const { return sgn(cross(d, l.d)) || where(l.p); }\n // +1: left, 0:\
    \ on, -1: right\n int where(const P &q) const { return sgn(cross(d, q - p)); }\n\
    \ P project(const P &q) const { return p + dot(q - p, d) / norm2(d) * d; }\n //\
    \ return  a,b,c of ax+by+c=0\n tuple<K, K, K> coef() const { return make_tuple(-d.y,\
    \ d.x, cross(p, d)); }\n friend ostream &operator<<(ostream &os, const Line &l)\
    \ { return os << l.p << \" + t\" << l.d; }\n friend Visualizer &operator<<(Visualizer\
    \ &vis, const Line &l) {\n  auto [a, b, c]= l.coef();\n  return vis.ofs << \"\
    Line \" << a << \" \" << b << \" \" << c << \"\\n\", vis;\n }\n};\n// p + t(q-p)\n\
    template <class K> Line<K> line_through(const Point<K> &p, const Point<K> &q)\
    \ { return Line(p, q - p); }\ntemplate <class K> bool is_parallel(const Line<K>\
    \ &l, const Line<K> &m) { return !sgn(cross(l.d, m.d)); }\ntemplate <class K>\
    \ bool is_orthogonal(const Line<K> &l, const Line<K> &m) { return !sgn(dot(l.d,\
    \ m.d)); }\n// 1 : properly crossing, 0 : disjoint parallel, 2 : same line\ntemplate\
    \ <class K> vector<Point<K>> cross_points(const Line<K> &l, const Line<K> &m)\
    \ {\n K a= cross(m.d, l.d), b= cross(l.p - m.p, l.d);\n if (sgn(a)) return {m.p\
    \ + b / a * m.d};  // properly crossing\n if (sgn(b)) return {};             \
    \      // disjoint parallel\n return {m.p, m.p + m.d};                 // same\
    \ line\n}\n// perpendicular bisector ............ p on leftside\ntemplate <class\
    \ K> Line<K> bisector(const Point<K> &p, const Point<K> &q) { return Line((p +\
    \ q) / 2, !(q - p)); }\n// angle bisector ........... parallel -> 1 line, non-parallel\
    \ -> 2 lines\ntemplate <class K> vector<Line<K>> bisector(const Line<K> &l, const\
    \ Line<K> &m) {\n auto cp= cross_points(l, m);\n if (cp.size() != 1) return {Line((l.p\
    \ + m.p) / 2, l.d)};\n auto d= l.d / norm(l.d) + m.d / norm(m.d);\n return {Line(cp[0],\
    \ d), Line(cp[0], !d)};\n}\ntemplate <class K> K dist2(const Line<K> &l, const\
    \ Point<K> &p) {\n K a= cross(l.d, p - l.p);\n return a * a / norm2(l.d);\n}\n\
    template <class K> K dist2(const Point<K> &p, const Line<K> &l) { return dist2(l,\
    \ p); }\ntemplate <class K> K dist2(const Line<K> &l, const Line<K> &m) { return\
    \ is_parallel(l, m) ? dist2(l, m.p) : 0; }\ntemplate <class K> Affine<K> reflect(const\
    \ Line<K> &l) {\n K a= l.d.x * l.d.x, b= l.d.x * l.d.y * 2, c= l.d.y * l.d.y,\
    \ d= a + c;\n a/= d, b/= d, c/= d, d= a - c;\n return {d, b, b, -d, Point<K>{c\
    \ * 2 * l.p.x - b * l.p.y, a * 2 * l.p.y - b * l.p.x}};\n}\ntemplate <class K>\
    \ Line<K> Affine<K>::operator()(const Line<K> &l) { return line_through((*this)(l.p),\
    \ (*this)(l.p + l.d)); }\n}\n"
  code: "#pragma once\n#include <vector>\n#include \"src/Geometry/Point.hpp\"\nnamespace\
    \ geo {\ntemplate <class K> struct Line {\n using P= Point<K>;\n P p, d;  // p+td\n\
    \ Line() {}\n // p + td\n Line(const P &p, const P &d): p(p), d(d) { assert(sgn(norm2(d)));\
    \ }\n // ax+by+c=0 ................. ax+by+c>0: left, ax+by+c=0: on, ax+by+c<0:\
    \ right\n Line(K a, K b, K c) {\n  int sa= sgn(a), sb= sgn(b);\n  assert(sa ||\
    \ sb);\n  d= P{b, -a}, p= sb ? P{0, -c / b} : P{-c / a, 0};\n }\n bool operator==(const\
    \ Line &l) const { return !sgn(cross(d, l.d)) && !where(l.p); }\n bool operator!=(const\
    \ Line &l) const { return sgn(cross(d, l.d)) || where(l.p); }\n // +1: left, 0:\
    \ on, -1: right\n int where(const P &q) const { return sgn(cross(d, q - p)); }\n\
    \ P project(const P &q) const { return p + dot(q - p, d) / norm2(d) * d; }\n //\
    \ return  a,b,c of ax+by+c=0\n tuple<K, K, K> coef() const { return make_tuple(-d.y,\
    \ d.x, cross(p, d)); }\n friend ostream &operator<<(ostream &os, const Line &l)\
    \ { return os << l.p << \" + t\" << l.d; }\n friend Visualizer &operator<<(Visualizer\
    \ &vis, const Line &l) {\n  auto [a, b, c]= l.coef();\n  return vis.ofs << \"\
    Line \" << a << \" \" << b << \" \" << c << \"\\n\", vis;\n }\n};\n// p + t(q-p)\n\
    template <class K> Line<K> line_through(const Point<K> &p, const Point<K> &q)\
    \ { return Line(p, q - p); }\ntemplate <class K> bool is_parallel(const Line<K>\
    \ &l, const Line<K> &m) { return !sgn(cross(l.d, m.d)); }\ntemplate <class K>\
    \ bool is_orthogonal(const Line<K> &l, const Line<K> &m) { return !sgn(dot(l.d,\
    \ m.d)); }\n// 1 : properly crossing, 0 : disjoint parallel, 2 : same line\ntemplate\
    \ <class K> vector<Point<K>> cross_points(const Line<K> &l, const Line<K> &m)\
    \ {\n K a= cross(m.d, l.d), b= cross(l.p - m.p, l.d);\n if (sgn(a)) return {m.p\
    \ + b / a * m.d};  // properly crossing\n if (sgn(b)) return {};             \
    \      // disjoint parallel\n return {m.p, m.p + m.d};                 // same\
    \ line\n}\n// perpendicular bisector ............ p on leftside\ntemplate <class\
    \ K> Line<K> bisector(const Point<K> &p, const Point<K> &q) { return Line((p +\
    \ q) / 2, !(q - p)); }\n// angle bisector ........... parallel -> 1 line, non-parallel\
    \ -> 2 lines\ntemplate <class K> vector<Line<K>> bisector(const Line<K> &l, const\
    \ Line<K> &m) {\n auto cp= cross_points(l, m);\n if (cp.size() != 1) return {Line((l.p\
    \ + m.p) / 2, l.d)};\n auto d= l.d / norm(l.d) + m.d / norm(m.d);\n return {Line(cp[0],\
    \ d), Line(cp[0], !d)};\n}\ntemplate <class K> K dist2(const Line<K> &l, const\
    \ Point<K> &p) {\n K a= cross(l.d, p - l.p);\n return a * a / norm2(l.d);\n}\n\
    template <class K> K dist2(const Point<K> &p, const Line<K> &l) { return dist2(l,\
    \ p); }\ntemplate <class K> K dist2(const Line<K> &l, const Line<K> &m) { return\
    \ is_parallel(l, m) ? dist2(l, m.p) : 0; }\ntemplate <class K> Affine<K> reflect(const\
    \ Line<K> &l) {\n K a= l.d.x * l.d.x, b= l.d.x * l.d.y * 2, c= l.d.y * l.d.y,\
    \ d= a + c;\n a/= d, b/= d, c/= d, d= a - c;\n return {d, b, b, -d, Point<K>{c\
    \ * 2 * l.p.x - b * l.p.y, a * 2 * l.p.y - b * l.p.x}};\n}\ntemplate <class K>\
    \ Line<K> Affine<K>::operator()(const Line<K> &l) { return line_through((*this)(l.p),\
    \ (*this)(l.p + l.d)); }\n}"
  dependsOn:
  - src/Geometry/Point.hpp
  isVerificationFile: false
  path: src/Geometry/Line.hpp
  requiredBy:
  - src/Geometry/Convex.hpp
  - src/Geometry/min_enclosing_circle.hpp
  - src/Geometry/SegmentArrangement.hpp
  - src/Geometry/Polygon.hpp
  - src/Geometry/intersection_area.hpp
  - src/Geometry/Segment.hpp
  - src/Geometry/Circle.hpp
  timestamp: '2023-10-10 00:58:36+09:00'
  verificationStatus: LIBRARY_SOME_WA
  verifiedWith:
  - test/aoj/1198.test.cpp
  - test/aoj/0356.test.cpp
  - test/aoj/CGL_1_A.test.cpp
  - test/aoj/CGL_1_B.test.cpp
  - test/aoj/2003.longdouble.test.cpp
  - test/aoj/2201.test.cpp
  - test/aoj/0273.test.cpp
  - test/aoj/0445.test.cpp
  - test/aoj/2159.longdouble.test.cpp
  - test/aoj/1157.test.cpp
  - test/aoj/3176.test.cpp
  - test/aoj/2009.rational.test.cpp
  - test/aoj/CGL_4_C.test.cpp
  - test/aoj/CGL_7_B.test.cpp
  - test/aoj/2256.test.cpp
  - test/aoj/1226.test.cpp
  - test/aoj/CGL_7_G.test.cpp
  - test/aoj/1050.test.cpp
  - test/aoj/0375.test.cpp
  - test/aoj/2514.test.cpp
  - test/aoj/1242.longdouble.test.cpp
  - test/aoj/0342.test.cpp
  - test/aoj/1190.test.cpp
  - test/aoj/2003.rational.test.cpp
  - test/aoj/1171.test.cpp
  - test/aoj/CGL_2_C.test.cpp
  - test/aoj/CGL_7_A.test.cpp
  - test/aoj/2402.test.cpp
  - test/aoj/2423.test.cpp
  - test/aoj/1132.test.cpp
  - test/aoj/2159.rational.test.cpp
  - test/aoj/1047.test.cpp
  - test/aoj/0253.test.cpp
  - test/aoj/CGL_2_D.test.cpp
  - test/aoj/CGL_4_B.test.cpp
  - test/aoj/CGL_7_C.test.cpp
  - test/aoj/CGL_7_I.test.cpp
  - test/aoj/2009.longdouble.test.cpp
  - test/aoj/3049.test.cpp
  - test/aoj/CGL_7_D.test.cpp
  - test/aoj/0265.test.cpp
  - test/aoj/CGL_2_A.test.cpp
  - test/aoj/CGL_7_F.test.cpp
  - test/aoj/1067.test.cpp
  - test/aoj/3034.test.cpp
  - test/aoj/1267.test.cpp
  - test/aoj/2626.test.cpp
  - test/aoj/1033.test.cpp
  - test/aoj/1242.rational.test.cpp
  - test/aoj/1342.test.cpp
  - test/aoj/CGL_7_H.test.cpp
  - test/aoj/CGL_7_E.test.cpp
  - test/aoj/CGL_3_C.test.cpp
  - test/aoj/1066.test.cpp
  - test/aoj/CGL_2_B.test.cpp
  - test/aoj/CGL_3_A.test.cpp
  - test/aoj/CGL_3_B.test.cpp
  - test/aoj/2495.test.cpp
  - test/aoj/2448.test.cpp
  - test/aoj/CGL_4_A.test.cpp
  - test/aoj/1183.test.cpp
  - test/atcoder/abc202_f.test.cpp
documentation_of: src/Geometry/Line.hpp
layout: document
title: "\u76F4\u7DDA"
---

## `Line<K>` クラス
二次元空間上の直線を表すクラス. \
`Point<K>` 型のpublicメンバ変数 `p`, `d` を持ち, 媒介変数 $t$ を用いた $\boldsymbol{p}+t\boldsymbol{d}$ で直線を表現している. \
点 $\boldsymbol{q}$ が 直線 $l: \boldsymbol{p}+t\boldsymbol{d}$ の左に位置するとは, ベクトル $\boldsymbol{q}-\boldsymbol{p}$ が $\boldsymbol{d}$ に対して反時計回りの時を指すこととする.

|メンバ関数|概要|
|---|---|
|`Line()`|デフォルトコンストラクタ|
|`Line(p,d)`|コンストラクタ. $\boldsymbol{p}+t\boldsymbol{d}$ で直線を定義.|
|`Line(a,b,c)`|コンストラクタ. $ax+by+c=0$ で直線を定義. <br> 点 $\boldsymbol{q}=(x,y)$ について $ax+by+c$ が 正, 負, 0 のとき, 点 $\boldsymbol{q}$ はそれぞれ 左, 右, 直線上 に位置することを意味する.|
|`where(q)`|点 $\boldsymbol{q}$ と直線の位置関係を表す. <br> +1: 直線の左, 0: 直線上, -1: 直線の右|
|`project(q)`|点 $\boldsymbol{q}$ から直線への垂線の足を返す.|
|`coef()`|$ax+by+c=0$と表した時の $a,b,c$ を返す.|

## その他関数

|名前|概要|
|---|---|
|`line_through(p,q)`|2点 $\boldsymbol{p},\boldsymbol{q}$ を通る直線を返す.|
|`is_parallel(l,m)`|2直線 $l,m$ が平行なら `true`.|
|`is_orthogonal(l,m)`|2直線 $l,m$ が垂直なら `true`.|
|`cross_points(l,m)`|2直線 $l,m$ の交点を返す. <br> 同一の直線なら直線上の2点を返し, 交わらないなら空集合を返す.<br> 返り値の型は `vector<Point<K>>`.|
|`bisector(p,q)`|点 $\boldsymbol{p},\boldsymbol{q}$ を端点とする線分の垂直二等分線を返す.|
|`bisector(l,m)`|直線 $l,m$ の角の二等分線を返す. <br> ただし平行ならちょうど真ん中を通る平行な直線を返す. <br> 通常は互いに垂直な2本を返す. <br> `Rational` は動かない. <br> 返り値の型は `vector<Line<K>>`. |
|`dist2(l,p)`<br>`dist2(p,l)`|直線 $l$ と 点 $\boldsymbol{p}$ の距離の二乗を返す.|
|`dist2(l,m)`|直線 $l$ と 直線 $m$ の距離の二乗を返す. ただし交わるときは 0.|
|`reflect(l)`|直線 $l$ を中心に折り返すようなアフィン変換を返す. 返り値の型は `Affine<K>`.|
